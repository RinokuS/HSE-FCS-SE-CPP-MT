# Соколовский Вацлав, БПИ191
## Вариант 23
[В данной папке](https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/tree/main/HomeWork_2) представлено выполнение первой домашней работы по работе с потоками на C++. Исходники лежат в [HomeWork_2/src/](https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/tree/main/HomeWork_2/src), а скриншоты в [HomeWork_2/pictures/](https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/tree/main/HomeWork_2/pictures) <br>
Код запускался из консоли с использованием команд:

	clang++ -std=c++17 -Xpreprocessor -fopenmp main.cpp -o main -lomp
    ./main

## OpenMP
При реализации данной задачи через OpenMP суть самой модели не изменилась, для параллельной работы конвейера было решено использовать omp sections, а для предотвращения race condition мы сбрасываем значения разделяемых переменных в память сразу после их изменения (директивой omp flush) <br>
Также для предотвращения одновременного владения консолью каждая из команд-выводов обернута в тело директивы omp critical.

## Условие
### Первая военная задача. 
Темной-темной ночью прапорщики Иванов, Петров и Нечепорчук занимаются хищением военного имущества со склада родной военной части. Будучи умными людьми и отличниками боевой и строевой подготовки, прапорщики ввели разделение труда: Иванов выносит имущество со склада, Петров грузит его в грузовик, а Нечепорчук подсчитывает рыночную стоимость добычи. Требуется составить многопоточное приложение, моделирующее деятельность прапорщиков. При решении использовать парадигму «производитель-потребитель».

## Модель вычислений
Для реализации задачи было решено использовать предложенную парадигму - «производитель-потребитель». <br>
Моделью выбран конвейер.

## Код программы
[Исходный код](https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/tree/main/HomeWork_2/src/main.cpp)<br>
[Собственный профайлер](https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/tree/main/HomeWork_2/src/profile.h)

Программа работает по модели конвейера: <br>
Иванов вытаскивает инвентарь со склада по одному элементу, Нечепорчук ожидает его и подсчитывает стоимость вынесенного объекта отправляя его на загрузку и освобождая место для нового объекта со склада, Петров ожидает Нечепорчука и загружает в грузовик уже подсчитанные объекты, освобождая место для нового. <br>
### Иванов -> Нечепорчук -> Петров

- **main**<br>
1. Считываем из консоли количество элементов инвентаря на складе. <br>
2. Засекаем время работы программы с помощью собственного профайлера и создаем 3 потока, симулирующих работу 3-х прапорщиков. <br>
3. Создаем параллельные секции с помощью omp и назначаем каждый этап конвейера своей секции. <br>
4. Выводим в консоль общую стоимость украденного инвентаря. <br>

<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_2/pictures/main.png" alt="" width="700" /> <br><br>

- **steal_from_warehouse**<br>
1. Инициализируем цикл по количеству необходимых к обработке элементов. <br>
2. Проверяем, вынесен ли уже объект со склада. Если да - ожидаем дальше, если нет - продвигаемся. <br>
3. Открываем критическую секцию и делаем в ней вывод в консоль. <br>
4. Выносим объект со склада. <br>
5. Сбрасываем значение объекта в память, чтобы у других потоков были актуальные значения.
6. Декреминируем количество оставшихся элементов. <br>

<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_2/pictures/steal.png" alt="" width="700" /> <br><br>

- **count_cost**<br>
1. Инициализируем цикл по количеству необходимых к обработке элементов. <br>
2. Проверяем, вынесел ли уже объект со склада. Если нет - ожидаем дальше, если да - продвигаемся. <br>
3. Проверяем, загружен ли уже предыдущий подсчитанный объект в грузовик. Если нет - ожидаем дальше, если да - продвигаемся. <br>
4. Подсчитываем стоимость объекта. <br>
5. Передаем объект на загрузку и освобождаем место для выгрузки со склада.  <br>
6. Сбрасываем значения объектов в память, чтобы у других потоков были актуальные значения.
7. Открываем критическую секцию и делаем в ней вывод в консоль. <br>
8. Декреминируем количество оставшихся элементов. <br>

<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_2/pictures/count.png" alt="" width="700" /> <br><br>

- **load_into_a_truck**<br>
1. Инициализируем цикл по количеству необходимых к обработке элементов. <br>
2. Проверяем, загружен ли уже предыдущий подсчитанный объект в грузовик. Если да - ожидаем дальше, если нет - продвигаемся. <br>
3. Открываем критическую секцию и делаем в ней вывод в консоль. <br>
4. Грузим объект в грузовик и освобождаем место для нового объекта после просчета его стоимости <br>
5. Сбрасываем значение объекта в память, чтобы у других потоков были актуальные значения.
6. Декреминируем количество оставшихся элементов. <br>

<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_2/pictures/load.png" alt="" width="700" /> <br><br>

- **profile**<br>
Также был написан собственный профайлер для удобства подсчета времени выполнения блоков кода.

<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_2/pictures/profile.png" alt="" width="700" /> <br><br>

## Тестирование программы
- **Тест 1**<br>
Для начала проверим примитивные варианты, то бишь количество элементов отрицательно, равно нулю и равно единице:<br>
<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_2/pictures/primitive.png" alt="" width="700" /> <br><br>
Программа отработала успешно <br><br>
- **Тест 2**<br>
Проведем обычный тест на 10 элементах:<br>
<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_2/pictures/normal.png" alt="" width="700" /> <br><br>
Программа отработала успешно <br><br>
- **Тест 3**<br>
Прверим большие значения (к сожалению на скрине поместится лишь часть данных):<br>
<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_2/pictures/big.png" alt="" width="700" /> <br><br>
Программа отработала успешно <br><br>

## Источники информации
1. Параллельное программирование на OpenMP. Директивы и их применение с псевдокодом: http://ccfit.nsu.ru/arom/data/openmp.pdf
2. Примеры директив OpenMP: https://docs.microsoft.com/ru-ru/cpp/parallel/openmp/reference/openmp-directives?view=msvc-160 <br>
3. Примеры программ с OpenMP: https://habr.com <br>
4. Возможные реализации парадигмы «производитель-потребитель»: Лекции дисциплины Архитектура вычислительных систем НИУ ВШЭ. <br>