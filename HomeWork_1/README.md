# Соколовский Вацлав, БПИ191
## Вариант 23
[В данной папке](https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/tree/main/HomeWork_1) представлено выполнение первой домашней работы по работе с потоками на C++. Исходники лежат в [HomeWork_1/src/](https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/tree/main/HomeWork_1/src), а скриншоты в [HomeWork_1/pictures/](https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/tree/main/HomeWork_1/pictures) <br>
Код запускался из консоли с использованием команд:

	clang++ -std=c++17 main.cpp -o main
    ./main

## Условие
### Первая военная задача. 
Темной-темной ночью прапорщики Иванов, Петров и Нечепорчук занимаются хищением военного имущества со склада родной военной части. Будучи умными людьми и отличниками боевой и строевой подготовки, прапорщики ввели разделение труда: Иванов выносит имущество со склада, Петров грузит его в грузовик, а Нечепорчук подсчитывает рыночную стоимость добычи. Требуется составить многопоточное приложение, моделирующее деятельность прапорщиков. При решении использовать парадигму «производитель-потребитель».

## Модель вычислений
Для реализации задачи было решено использовать предложенную парадигму - «производитель-потребитель». <br>
Моделью выбран конвейер.

## Код программы
[Исходный код](https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/tree/main/HomeWork_1/src/main.cpp)<br>
[Собственный профайлер](https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/tree/main/HomeWork_1/src/profile.h)

Программа работает по модели конвейера: <br>
Иванов вытаскивает инвентарь со склада по одному элементу, Нечепорчук ожидает его и подсчитывает стоимость вынесенного объекта отправляя его на загрузку и освобождая место для нового объекта со склада, Петров ожидает Нечепорчука и загружает в грузовик уже подсчитанные объекты, освобождая место для нового. <br>
### Иванов -> Нечепорчук -> Петров

- **main**<br>
1. Считываем из консоли количество элементов инвентаря на складе. <br>
2. Засекаем время работы программы с помощью собственного профайлера и создаем 3 потока, симулирующих работу 3-х прапорщиков. <br>
3. Отпускаем потоки Иванова и Нечепорчука в свободное плавание и джойним потом Петрова к основному (ибо Петров заканчивает работу последним, и после его завершения можно завершать программу). <br>
4. Выводим в консоль общую стоимость украденного инвентаря. <br>

<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_1/pictures/main.png" alt="" width="700" /> <br><br>

- **steal_from_warehouse**<br>
1. Инициализируем цикл по количеству необходимых к обработке элементов. <br>
2. Проверяем, вынесен ли уже объект со склада. Если да - ожидаем дальше, если нет - продвигаемся. <br>
3. Ставим мьютекс (во имя избежания одновременного владения несколькими потоками). <br>
4. Выносим объект со склада. <br>
5. Декреминируем количество оставшихся элементов. <br>

<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_1/pictures/steal.png" alt="" width="700" /> <br><br>

- **count_cost**<br>
1. Инициализируем цикл по количеству необходимых к обработке элементов. <br>
2. Проверяем, вынесел ли уже объект со склада. Если нет - ожидаем дальше, если да - продвигаемся. <br>
3. Проверяем, загружен ли уже предыдущий подсчитанный объект в грузовик. Если нет - ожидаем дальше, если да - продвигаемся. <br>
4. Ставим мьютекс (во имя избежания одновременного владения несколькими потоками). <br>
5. Подсчитываем стоимость объекта. <br>
6. Передаем объект на загрузку и освобождаем место для выгрузки со склада.  <br>
7. Декреминируем количество оставшихся элементов. <br>

<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_1/pictures/count.png" alt="" width="700" /> <br><br>

- **load_into_a_truck**<br>
1. Инициализируем цикл по количеству необходимых к обработке элементов. <br>
2. Проверяем, загружен ли уже предыдущий подсчитанный объект в грузовик. Если да - ожидаем дальше, если нет - продвигаемся. <br>
4. Ставим мьютекс (во имя избежания одновременного владения несколькими потоками). <br>
5. Грузим объект в грузовик и освобождаем место для нового объекта после просчета его стоимости <br>
6. Декреминируем количество оставшихся элементов. <br>

<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_1/pictures/load.png" alt="" width="700" /> <br><br>

- **profile**<br>
Также для был написан собственный профайлер для удобства подсчета времени выполнения блоков кода.

<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_1/pictures/profile.png" alt="" width="700" /> <br><br>

## Тестирование программы
- **Тест 1**<br>
Для начала проверим примитивные варианты, то бишь количество элементов отрицательно, равно нулю и равно единице:<br>
<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_1/pictures/primitive.png" alt="" width="700" /> <br><br>
Программа отработала успешно <br><br>
- **Тест 2**<br>
Проведем обычный тест на 10 элементах:<br>
<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_1/pictures/normal.png" alt="" width="700" /> <br><br>
Программа отработала успешно <br><br>
- **Тест 3**<br>
Прверим большие значения (к сожалению на скрине поместится лишь часть данных):<br>
<img src="https://github.com/RinokuS/HSE-FCS-SE-CPP-MT/blob/main/HomeWork_1/pictures/big.png" alt="" width="700" /> <br><br>
Программа отработала успешно <br><br>

## Источники информации
1. Информация о mutex, lock_guard, thread: https://en.cppreference.com <br>
2. Информация о mutex с примерами: http://scrutator.me/post/2012/04/04/parallel-world-p1.aspx <br>
3. Примеры многопоточных конвейеров на C++: https://towardsdatascience.com/how-to-build-a-multi-threaded-pipeline-in-c-with-std-async-78edc19e862d <br>
4. Вопросы по многопоточным конвейерам на С++: https://www.cyberforum.ru/cpp-beginners <br>
5. Возможные реализации парадигмы «производитель-потребитель»: Лекции дисциплины Архитектура вычислительных систем НИУ ВШЭ. <br>